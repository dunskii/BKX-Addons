<?php
/**
 * Vulnerability Scanner Service.
 *
 * @package BookingX\PCICompliance
 */

namespace BookingX\PCICompliance\Services;

defined( 'ABSPATH' ) || exit;

/**
 * VulnerabilityScanner class.
 *
 * Scans for security vulnerabilities per PCI DSS Requirement 11.
 */
class VulnerabilityScanner {

	/**
	 * Run vulnerability scan.
	 *
	 * @return array
	 */
	public function scan() {
		$vulnerabilities = array();

		// Check WordPress core.
		$vulnerabilities = array_merge( $vulnerabilities, $this->check_wordpress_core() );

		// Check plugins.
		$vulnerabilities = array_merge( $vulnerabilities, $this->check_plugins() );

		// Check themes.
		$vulnerabilities = array_merge( $vulnerabilities, $this->check_themes() );

		// Check file permissions.
		$vulnerabilities = array_merge( $vulnerabilities, $this->check_file_permissions() );

		// Check database security.
		$vulnerabilities = array_merge( $vulnerabilities, $this->check_database_security() );

		// Check SSL/TLS.
		$vulnerabilities = array_merge( $vulnerabilities, $this->check_ssl() );

		// Store discovered vulnerabilities.
		$this->store_vulnerabilities( $vulnerabilities );

		return $vulnerabilities;
	}

	/**
	 * Check WordPress core for vulnerabilities.
	 *
	 * @return array
	 */
	private function check_wordpress_core() {
		$vulnerabilities = array();
		global $wp_version;

		// Check if WordPress is outdated.
		if ( ! function_exists( 'get_core_updates' ) ) {
			require_once ABSPATH . 'wp-admin/includes/update.php';
		}

		$updates = get_core_updates();
		if ( ! empty( $updates ) && isset( $updates[0]->response ) && 'upgrade' === $updates[0]->response ) {
			$vulnerabilities[] = array(
				'title'              => __( 'WordPress Core Outdated', 'bkx-pci-compliance' ),
				'description'        => sprintf(
					/* translators: 1: Current version, 2: Latest version */
					__( 'WordPress %1$s is installed. Version %2$s is available.', 'bkx-pci-compliance' ),
					$wp_version,
					$updates[0]->version
				),
				'severity'           => 'high',
				'affected_component' => 'WordPress Core',
				'remediation'        => __( 'Update WordPress to the latest version immediately.', 'bkx-pci-compliance' ),
				'pci_requirements'   => '6.2',
			);
		}

		return $vulnerabilities;
	}

	/**
	 * Check plugins for vulnerabilities.
	 *
	 * @return array
	 */
	private function check_plugins() {
		$vulnerabilities = array();

		if ( ! function_exists( 'get_plugins' ) ) {
			require_once ABSPATH . 'wp-admin/includes/plugin.php';
		}

		$plugins = get_plugins();
		$updates = get_plugin_updates();

		foreach ( $updates as $plugin_file => $update_info ) {
			$plugin_data = $plugins[ $plugin_file ] ?? array();

			$vulnerabilities[] = array(
				'title'              => sprintf(
					/* translators: %s: Plugin name */
					__( 'Plugin Update Available: %s', 'bkx-pci-compliance' ),
					$plugin_data['Name'] ?? $plugin_file
				),
				'description'        => sprintf(
					/* translators: 1: Current version, 2: New version */
					__( 'Current version %1$s, new version %2$s available.', 'bkx-pci-compliance' ),
					$plugin_data['Version'] ?? 'unknown',
					$update_info->update->new_version ?? 'unknown'
				),
				'severity'           => 'medium',
				'affected_component' => 'Plugin: ' . ( $plugin_data['Name'] ?? $plugin_file ),
				'remediation'        => __( 'Update plugin to the latest version.', 'bkx-pci-compliance' ),
				'pci_requirements'   => '6.2',
			);
		}

		// Check for abandoned plugins (not updated in 2+ years).
		foreach ( $plugins as $plugin_file => $plugin_data ) {
			if ( ! is_plugin_active( $plugin_file ) ) {
				continue;
			}

			// Check if plugin hasn't been updated recently.
			$plugin_slug = dirname( $plugin_file );
			if ( $plugin_slug && '.' !== $plugin_slug ) {
				$api_url  = 'https://api.wordpress.org/plugins/info/1.0/' . $plugin_slug . '.json';
				$response = wp_remote_get( $api_url, array( 'timeout' => 5 ) );

				if ( ! is_wp_error( $response ) ) {
					$plugin_info = json_decode( wp_remote_retrieve_body( $response ) );
					if ( $plugin_info && isset( $plugin_info->last_updated ) ) {
						$last_updated = strtotime( $plugin_info->last_updated );
						$two_years    = strtotime( '-2 years' );

						if ( $last_updated < $two_years ) {
							$vulnerabilities[] = array(
								'title'              => sprintf(
									/* translators: %s: Plugin name */
									__( 'Potentially Abandoned Plugin: %s', 'bkx-pci-compliance' ),
									$plugin_data['Name']
								),
								'description'        => __( 'This plugin has not been updated in over 2 years and may contain security vulnerabilities.', 'bkx-pci-compliance' ),
								'severity'           => 'medium',
								'affected_component' => 'Plugin: ' . $plugin_data['Name'],
								'remediation'        => __( 'Consider replacing with an actively maintained alternative.', 'bkx-pci-compliance' ),
								'pci_requirements'   => '6.2',
							);
						}
					}
				}
			}
		}

		return $vulnerabilities;
	}

	/**
	 * Check themes for vulnerabilities.
	 *
	 * @return array
	 */
	private function check_themes() {
		$vulnerabilities = array();

		$updates = get_theme_updates();
		foreach ( $updates as $theme_slug => $update_info ) {
			$theme = wp_get_theme( $theme_slug );

			$vulnerabilities[] = array(
				'title'              => sprintf(
					/* translators: %s: Theme name */
					__( 'Theme Update Available: %s', 'bkx-pci-compliance' ),
					$theme->get( 'Name' )
				),
				'description'        => sprintf(
					/* translators: 1: Current version, 2: New version */
					__( 'Current version %1$s, new version %2$s available.', 'bkx-pci-compliance' ),
					$theme->get( 'Version' ),
					$update_info->update['new_version'] ?? 'unknown'
				),
				'severity'           => 'low',
				'affected_component' => 'Theme: ' . $theme->get( 'Name' ),
				'remediation'        => __( 'Update theme to the latest version.', 'bkx-pci-compliance' ),
				'pci_requirements'   => '6.2',
			);
		}

		return $vulnerabilities;
	}

	/**
	 * Check file permissions.
	 *
	 * @return array
	 */
	private function check_file_permissions() {
		$vulnerabilities = array();

		// Check wp-config.php permissions.
		$wp_config = ABSPATH . 'wp-config.php';
		if ( file_exists( $wp_config ) ) {
			$perms = fileperms( $wp_config ) & 0777;
			if ( $perms > 0644 ) {
				$vulnerabilities[] = array(
					'title'              => __( 'wp-config.php Permissions Too Permissive', 'bkx-pci-compliance' ),
					'description'        => sprintf(
						/* translators: %s: Current permissions */
						__( 'wp-config.php has permissions %s. Should be 644 or more restrictive.', 'bkx-pci-compliance' ),
						decoct( $perms )
					),
					'severity'           => 'high',
					'affected_component' => 'wp-config.php',
					'remediation'        => __( 'Change file permissions to 644 or 600.', 'bkx-pci-compliance' ),
					'pci_requirements'   => '7.1',
				);
			}
		}

		// Check .htaccess permissions.
		$htaccess = ABSPATH . '.htaccess';
		if ( file_exists( $htaccess ) ) {
			$perms = fileperms( $htaccess ) & 0777;
			if ( $perms > 0644 ) {
				$vulnerabilities[] = array(
					'title'              => __( '.htaccess Permissions Too Permissive', 'bkx-pci-compliance' ),
					'description'        => sprintf(
						/* translators: %s: Current permissions */
						__( '.htaccess has permissions %s. Should be 644 or more restrictive.', 'bkx-pci-compliance' ),
						decoct( $perms )
					),
					'severity'           => 'medium',
					'affected_component' => '.htaccess',
					'remediation'        => __( 'Change file permissions to 644.', 'bkx-pci-compliance' ),
					'pci_requirements'   => '7.1',
				);
			}
		}

		// Check uploads directory.
		$uploads = wp_upload_dir();
		if ( is_writable( $uploads['basedir'] ) ) {
			// This is expected, but check for PHP execution.
			$htaccess_uploads = $uploads['basedir'] . '/.htaccess';
			if ( ! file_exists( $htaccess_uploads ) ) {
				$vulnerabilities[] = array(
					'title'              => __( 'Uploads Directory Missing .htaccess', 'bkx-pci-compliance' ),
					'description'        => __( 'The uploads directory does not have an .htaccess file to prevent PHP execution.', 'bkx-pci-compliance' ),
					'severity'           => 'medium',
					'affected_component' => 'uploads directory',
					'remediation'        => __( 'Add .htaccess with "php_flag engine off" or equivalent.', 'bkx-pci-compliance' ),
					'pci_requirements'   => '6.5',
				);
			}
		}

		return $vulnerabilities;
	}

	/**
	 * Check database security.
	 *
	 * @return array
	 */
	private function check_database_security() {
		$vulnerabilities = array();
		global $wpdb;

		// Check database prefix.
		if ( 'wp_' === $wpdb->prefix ) {
			$vulnerabilities[] = array(
				'title'              => __( 'Default Database Prefix', 'bkx-pci-compliance' ),
				'description'        => __( 'Using the default "wp_" database prefix makes SQL injection attacks easier.', 'bkx-pci-compliance' ),
				'severity'           => 'medium',
				'affected_component' => 'Database',
				'remediation'        => __( 'Consider changing the database prefix to a custom value.', 'bkx-pci-compliance' ),
				'pci_requirements'   => '2.1',
			);
		}

		return $vulnerabilities;
	}

	/**
	 * Check SSL/TLS configuration.
	 *
	 * @return array
	 */
	private function check_ssl() {
		$vulnerabilities = array();

		// Check if site uses HTTPS.
		$site_url = get_option( 'siteurl' );
		if ( strpos( $site_url, 'https://' ) !== 0 ) {
			$vulnerabilities[] = array(
				'title'              => __( 'Site Not Using HTTPS', 'bkx-pci-compliance' ),
				'description'        => __( 'The site URL is not configured to use HTTPS.', 'bkx-pci-compliance' ),
				'severity'           => 'critical',
				'affected_component' => 'SSL/TLS',
				'remediation'        => __( 'Configure site to use HTTPS and obtain an SSL certificate.', 'bkx-pci-compliance' ),
				'pci_requirements'   => '4.1',
			);
		}

		// Check for mixed content issues by checking if current request is SSL.
		if ( ! is_ssl() && is_admin() ) {
			$vulnerabilities[] = array(
				'title'              => __( 'Admin Not Using HTTPS', 'bkx-pci-compliance' ),
				'description'        => __( 'The admin area is being accessed without HTTPS.', 'bkx-pci-compliance' ),
				'severity'           => 'high',
				'affected_component' => 'SSL/TLS',
				'remediation'        => __( 'Force HTTPS for all admin access.', 'bkx-pci-compliance' ),
				'pci_requirements'   => '4.1',
			);
		}

		return $vulnerabilities;
	}

	/**
	 * Store discovered vulnerabilities.
	 *
	 * @param array $vulnerabilities Vulnerabilities to store.
	 */
	private function store_vulnerabilities( $vulnerabilities ) {
		global $wpdb;

		foreach ( $vulnerabilities as $vuln ) {
			// Check if vulnerability already exists.
			$hash = md5( $vuln['title'] . $vuln['affected_component'] );

			// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
			$existing = $wpdb->get_var(
				$wpdb->prepare(
					"SELECT id FROM {$wpdb->prefix}bkx_pci_vulnerabilities
					WHERE vulnerability_id = %s AND status NOT IN ('resolved', 'false_positive')",
					$hash
				)
			);

			if ( ! $existing ) {
				// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery
				$wpdb->insert(
					$wpdb->prefix . 'bkx_pci_vulnerabilities',
					array(
						'vulnerability_id'   => $hash,
						'title'              => $vuln['title'],
						'description'        => $vuln['description'],
						'severity'           => $vuln['severity'],
						'affected_component' => $vuln['affected_component'],
						'status'             => 'open',
						'remediation'        => $vuln['remediation'],
						'pci_requirements'   => $vuln['pci_requirements'],
						'discovered_at'      => current_time( 'mysql' ),
						'created_at'         => current_time( 'mysql' ),
					),
					array( '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s' )
				);
			}
		}
	}

	/**
	 * Resolve vulnerability.
	 *
	 * @param int    $id         Vulnerability ID.
	 * @param string $status     New status.
	 * @param string $resolution Resolution notes.
	 * @return bool|\WP_Error
	 */
	public function resolve_vulnerability( $id, $status, $resolution = '' ) {
		global $wpdb;

		$valid_statuses = array( 'resolved', 'in_progress', 'accepted', 'false_positive' );
		if ( ! in_array( $status, $valid_statuses, true ) ) {
			return new \WP_Error( 'invalid_status', __( 'Invalid vulnerability status.', 'bkx-pci-compliance' ) );
		}

		$data = array(
			'status' => $status,
		);
		$format = array( '%s' );

		if ( 'resolved' === $status || 'false_positive' === $status ) {
			$data['resolved_at'] = current_time( 'mysql' );
			$data['resolved_by'] = get_current_user_id();
			$format[]            = '%s';
			$format[]            = '%d';
		}

		if ( ! empty( $resolution ) ) {
			$data['remediation'] = $resolution;
			$format[]            = '%s';
		}

		// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
		$result = $wpdb->update(
			$wpdb->prefix . 'bkx_pci_vulnerabilities',
			$data,
			array( 'id' => $id ),
			$format,
			array( '%d' )
		);

		return $result !== false;
	}

	/**
	 * Get vulnerabilities.
	 *
	 * @param array $args Query arguments.
	 * @return array
	 */
	public function get_vulnerabilities( $args = array() ) {
		global $wpdb;

		$defaults = array(
			'per_page' => 50,
			'page'     => 1,
			'status'   => null,
			'severity' => null,
		);

		$args   = wp_parse_args( $args, $defaults );
		$where  = array( '1=1' );
		$values = array();

		if ( $args['status'] ) {
			$where[]  = 'status = %s';
			$values[] = sanitize_key( $args['status'] );
		}

		if ( $args['severity'] ) {
			$where[]  = 'severity = %s';
			$values[] = sanitize_key( $args['severity'] );
		}

		$where_clause = implode( ' AND ', $where );
		$offset       = ( $args['page'] - 1 ) * $args['per_page'];

		$query    = "SELECT * FROM {$wpdb->prefix}bkx_pci_vulnerabilities WHERE {$where_clause} ORDER BY FIELD(severity, 'critical', 'high', 'medium', 'low'), discovered_at DESC LIMIT %d OFFSET %d";
		$values[] = $args['per_page'];
		$values[] = $offset;

		// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching, WordPress.DB.PreparedSQL.NotPrepared
		$vulnerabilities = $wpdb->get_results( $wpdb->prepare( $query, $values ), ARRAY_A );

		// Get counts by severity.
		// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
		$counts = $wpdb->get_results(
			"SELECT severity, COUNT(*) as count FROM {$wpdb->prefix}bkx_pci_vulnerabilities WHERE status = 'open' GROUP BY severity",
			ARRAY_A
		);

		$severity_counts = array(
			'critical' => 0,
			'high'     => 0,
			'medium'   => 0,
			'low'      => 0,
		);

		foreach ( $counts as $count ) {
			$severity_counts[ $count['severity'] ] = (int) $count['count'];
		}

		return array(
			'vulnerabilities' => $vulnerabilities,
			'counts'          => $severity_counts,
			'total'           => array_sum( $severity_counts ),
		);
	}

	/**
	 * Get vulnerability by ID.
	 *
	 * @param int $id Vulnerability ID.
	 * @return array|null
	 */
	public function get_vulnerability( $id ) {
		global $wpdb;

		// phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
		return $wpdb->get_row(
			$wpdb->prepare(
				"SELECT * FROM {$wpdb->prefix}bkx_pci_vulnerabilities WHERE id = %d",
				$id
			),
			ARRAY_A
		);
	}
}
